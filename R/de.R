#' run differential expression with dream
#' 
#' @param f
#' Formula to be used as input to dream.
#' 
#' @param dge
#' This should be an `edgeR::DGEList` to be used as input to differential expression.
#' This should be filtered to remove low count genes and, if necessary, low variance genes.
#' 
#' @param L
#' L can be a list of contrasts (see limma vignettes) that are to be
#' compared by the model. If this is the case, the parameter `L_is_contrasts`
#' should be set to `TRUE`.
#' 
#' If L is not a list of contrasts, set `L_is_contrasts` to `FALSE`. In this
#' case, L is used as the `coef` argument to limma's `topTable` function. If
#' you supply a single coef (i.e. a character or character vector) then this 
#' is used directly as input to `topTable`, else you can supply a list of
#' values to be passed to `topTable`. These are all appended to the final 
#' list to be returned.
#' 
#' @param debug
#' If true, this limits the number of features used in the analysis to 500.
#' Makes things quicker for testing
#' 
#' @param L_is_contrasts
#' See the `L` parameter. If this is set to `TRUE` then `L` is treated as a list
#' of limma contrasts.
#' 
#' If this parameter is `FALSE`, then `L` is instead fed into `topTable` via the
#' `coef` argument. Specifically, if you only supply one set of coefs then this 
#' is fed directly to the `topTable` command, else if you supply a list of coefs
#' these are each used to geenrate separate `topTable` outputs.
#' 
#' @return 
#' Returns a list that contains an entry called "fit", containing the result 
#' of the `dream` function. This list will also contain at least one set of
#' results generated by limma's `topTable` function. These will be named
#' by concatenating the name of the contrast to the string "_tt".

run_dream <- function(f, dge, L, debug=FALSE, L_is_contrasts=FALSE) {
    
    if (debug & nrow(dge) > 500) {
        dge <- dge[1:500,]
    }
    
    # transform to log cpm, estimate mean variance relationship, prepare data for mixed modelling
    vobjDream <- voomWithDreamWeights(dge, f, dge$samples, plot = TRUE)
    
    if (L_is_contrasts) {
        
        coefs_to_compare <- L
        coef_names <- c()
        
        for (L_name in names(coefs_to_compare)) {
            
            coefs_to_compare[[L_name]] <- getContrast(vobjDream, f, dge$samples, coefs_to_compare[[L_name]])
            
            if (typeof(L) == "list") {
                L <- coefs_to_compare[[L_name]]
            } else {
                L <- cbind(L, coefs_to_compare[[L_name]])
            }
            
            coef_names <- c(coef_names, L_name)
        }
        
        colnames(L) <- coef_names
        
        fitmm <- dream(vobjDream, f, dge$samples, L)
        model_and_table <- list("fit" = fitmm)
        
        for (contrast in colnames(L)) {
            
            tt <- topTable(fitmm, coef = contrast, number = nrow(dge))
            tt$ensembl_id <- rownames(tt)
            tt <- dplyr::left_join(tt, dge$genes)
            
            model_and_table[[paste0(contrast, "_tt")]] <- tt
        }
        
    } else {
        
        fitmm <- dream(vobjDream, f, dge$samples)
        model_and_table <- list("fit" = fitmm)
        
        for (contrast_name in names(L)) {
            
            contrast <- L[[contrast_name]]
            
            tt <- topTable(fitmm, coef = contrast, number = nrow(dge))
            tt$ensembl_id <- rownames(tt)
            tt <- dplyr::left_join(tt, dge$genes)
            
            model_and_table[[paste0(contrast_name, "_tt")]] <- tt
        }
    }
    
    return(model_and_table)
}

#' Run GSEA based on differential expression results

run_enrichment <- function(tt, de_p_cutoff=0.01, go_p_cutoff=0.05, desc="case_control") {
    
    # this named vector is required to create a topGO object
    geneList <- tt$P.Value
    names(geneList) <- tt$ensembl_id
    
    df_terms <- list()
    
    #-------- GO
    
    # get raw p value cutoff from adjusted p values
    p_val_cutoff <- max(tt$P.Value[tt$adj.P.Val < de_p_cutoff])
    
    # this selects the significant genes in the topgo object
    get_sig_genes <- function(allScore) {
        return(allScore <= p_val_cutoff)
    }
    
    # create the topgo object
    tg_object <- new(
        "topGOdata", 
        description = desc,
        ontology = "BP",
        allGenes = geneList,
        annotationFun = annFUN.org,
        ID = "ensembl",
        geneSelectionFun = get_sig_genes,
        mapping = "org.Hs.eg.db"
    )
    
    # run topGO GSEA
    tg_terms <- runTest(tg_object, "weight01", "fisher")
    
    # extract topGO results
    df_terms[["GO"]] <- data.frame(tg_terms@score[tg_terms@score < go_p_cutoff])
    colnames(df_terms[["GO"]]) <- "p_value"
    
    df_terms[["GO"]]$go_term <- rownames(df_terms[["GO"]])
    
    go_terms_to_descriptions <- as.list(GOTERM)
    
    df_terms[["GO"]]$term_description <- sapply(df_terms[["GO"]]$go_term, function(t) {
        return(go_terms_to_descriptions[[t]]@Term)
    })

    #-------- REACTOME
        
    names(geneList) <- mapIds(org.Hs.eg.db, keys=names(geneList), column="ENTREZID", keytype="ENSEMBL", multiVals="first")
    de <- names(geneList)[geneList <= p_val_cutoff]
    
    df_terms[["REACTOME"]] <- enrichPathway(de, qvalueCutoff = go_p_cutoff, universe = names(geneList), maxGSSize = 10000)
    
    return(df_terms)
}

#' Make plots describing an enrichment analysis

plot_enrichment <- function(reactome_terms, go_p_cutoff = 0.05, num_terms = 30, n = 10) {
    
    # e_plot <- ReactomePA::emapplot(enrichplot::pairwise_termsim(reactome_terms), showCategory = num_terms, cex_line=0.2)
    # 
    # d_plot <- ReactomePA::dotplot(reactome_terms, showCategory = num_terms)
    
    u_plot <- enrichplot::upsetplot(reactome_terms, n = 10)
    
    return(u_plot)
}

#' Create volcano plots from differential expression data

tt_volcano_plot <- function(tt, fc_col="logFC", de_p_cutoff=0.01, n_pos_fc=8, n_neg_fc=n_pos_fc, n_pos_pval=n_pos_fc, n_neg_pval=n_pos_pval) {
    
    colnames(tt) <- gsub("adj_p", "adj.P.Val", colnames(tt))
    colnames(tt) <- gsub("pval", "P.Value", colnames(tt))
    colnames(tt) <- gsub("term_id", "gene_id", colnames(tt))
    
    # prepare colouring
    tt$de_col <- mapply(tt$adj.P.Val, tt[[fc_col]], FUN = function(adj_p, fc) {
        if (adj_p < de_p_cutoff) {
            if (fc > 0) {
                return("upreg")
            } else {
                return("downreg")
            }
        } else {
            return("non_sig")
        }
    })
    
    tt$de_col <- factor(tt$de_col, c("downreg", "non_sig", "upreg"))

    # label the top up and downregulated genes
    top_pos_fc <- Rfast::nth(tt[[fc_col]][tt$adj.P.Val < de_p_cutoff], n_pos_fc, descending = TRUE)
    top_neg_fc <- Rfast::nth(tt[[fc_col]][tt$adj.P.Val < de_p_cutoff], n_neg_fc, descending = FALSE)
    top_pos_pval <- Rfast::nth(tt$P.Value[tt[[fc_col]] > 0 & tt$adj.P.Val < de_p_cutoff], n_pos_pval, descending = FALSE)
    top_neg_pval <- Rfast::nth(tt$P.Value[tt[[fc_col]] < 0 & tt$adj.P.Val < de_p_cutoff], n_neg_pval, descending = FALSE)
    
    tt_to_label <- tt$adj.P.Val <= de_p_cutoff & (
                       tt[[fc_col]] >= top_pos_fc |
                       tt[[fc_col]] <= top_neg_fc |
                       (tt$P.Value <= top_pos_pval & tt[[fc_col]] > 0) |
                       (tt$P.Value <= top_neg_pval & tt[[fc_col]] < 0))
    
    tt$logp <- -log10(tt$P.Value)
    
    # make the ggplot
    volcano_plot <- ggplot(tt, aes_string(fc_col, "logp", col="de_col")) +
        geom_point() +
        scale_color_manual(values = c("downreg" = "#2C7BB6", "non_sig" = "black", "upreg" = "#D7191C")) +
        geom_text_repel(aes(label = gene_id), size = 2.25, color = "black", data = subset(tt, tt_to_label)) +
        theme(legend.position = "none") +
        xlab("Effect size")
    
    return(volcano_plot)
}

#' Make violin plots from logCPM data

make_violin_plots <- function(cpm_vec, label_vec, colour_vec) {
    
    ggplot_input <- data.frame("cpm"=cpm_vec, "label"=label_vec)
    
    violin_plot <- ggplot(ggplot_input, aes(label, cpm)) +
        geom_violin(aes(fill=label)) +
        scale_fill_manual(values=colour_vec) +
        theme(legend.title = element_blank(), axis.title.x=element_blank()) +
        geom_boxplot(width=0.1) +
        ylab("logCPM")
    
    return(violin_plot)
}

#' Run a single linear mixed model

single_lmer <- function(data, formula_string, REML=TRUE) {
    
    out.model <- tryCatch(
        lmerTest::lmer(
            as.formula(formula_string),
            data=data,
            REML=REML,
            control = lmerControl(check.conv.singular = "ignore"
            )),
        warning = function(w) {
        return(lmerTest::lmer(
            as.formula(formula_string),
            data=data,
            REML=REML,
            control=lmerControl(optimizer = "Nelder_Mead", check.conv.singular = "ignore")
        ))
        }
    )
    
    
    if(class(out.model) == "lmerModLmerTest") {
        return(out.model)
        
    } else {
        stop("Convergence issue not caught by single_lmer")
    }
}

#' Differential expression of gene sets

eset_de <- function(se, eset, formula_string, REML=TRUE) {
    
    col_data <- data.frame(colData(se))
    
    set_models <- list()
    
    for (i in 1:nrow(eset)) {
        
        # print(paste0(i, " / ", nrow(eset)))
        
        set_name <- rownames(eset)[i]
        set_data <- data.frame(sample_id = colnames(eset), set_expr = eset[i,])
        
        set_data_with_covariates <- dplyr::left_join(set_data, col_data, by = c("sample_id" = "sample_id"))
        
        set_models[[set_name]] <- single_lmer(set_data_with_covariates, formula_string, REML = REML)
    }
    
    return(set_models)
}

#' longitudinal plot

plot_longitudinal <- function(single_gene_normalised_logcpm, output_dir, gene_name, plot_type, model = NULL) {
    
    if (plot_type == "interaction") {
        formula <- "gene_expr ~ bs(time_from_first_x, degree=2) * grouped_WHO_severity + sex + ethnicity + calc_age + (1 | individual_id)"
    } else {
        formula <- "gene_expr ~ bs(time_from_first_x, degree=2) + sex + ethnicity + calc_age + (1 | individual_id)"
    }
    
    if (is.null(model)) {
        single_gene_lmer <- single_lmer(single_gene_normalised_logcpm, formula)
    } else {
        single_gene_lmer <- model
    }
    
    ind_table <- table(single_gene_normalised_logcpm$individual_id)
    no_individual_points <- single_gene_normalised_logcpm[!(single_gene_normalised_logcpm$individual_id %in% names(ind_table)[ind_table == 1]),]
    
    if (plot_type == "interaction") {
        
        # use ggemmeans to estimate confidence intervals/fits
        predictions <- ggemmeans(single_gene_lmer, c("time_from_first_x [all]", "grouped_WHO_severity"))
        names(predictions) <- c("time_from_first_x", "gene_expr", "std.error", "conf.low", "conf.high", "grouped_WHO_severity")
        
        # plot just the CI estimations
        estimates_only <- ggplot(predictions, aes(time_from_first_x, gene_expr, group=grouped_WHO_severity, fill=grouped_WHO_severity)) +
            geom_line(aes(colour=grouped_WHO_severity), size=1.7) +
            geom_ribbon(aes(ymin=conf.low, ymax=conf.high), alpha=0.055) +
            scale_color_manual(values=c("#2C7BB6", "#D7191C")) +
            scale_fill_manual(values=c("#2C7BB6", "#D7191C"))
        
        raw_plot <- ggplot(single_gene_normalised_logcpm[!(single_gene_normalised_logcpm$individual_id %in% names(ind_table)[ind_table == 1]),], aes(time_from_first_x, gene_expr, col = grouped_WHO_severity)) +
            geom_point(alpha = 0.7, size=0.7) +
            geom_line(aes(group = individual_id), alpha = 0.7, size=0.8) +
            scale_color_manual(values = c("#2C7BB6", "#D7191C")) +
            facet_wrap(~grouped_WHO_severity)
        
    } else {
        
        # use ggemmeans to estimate confidence intervals/fits
        predictions <- ggemmeans(single_gene_lmer, c("time_from_first_x [all]"))
        names(predictions) <- c("time_from_first_x", "gene_expr", "std.error", "conf.low", "conf.high")
        
        # plot just the CI estimations
        estimates_only <- ggplot(predictions, aes(time_from_first_x, gene_expr)) +
            geom_line(size=1.7) +
            geom_ribbon(aes(ymin=conf.low, ymax=conf.high), alpha=0.055)
        
        # plot the raw points
        raw_plot <- ggplot(no_individual_points, aes(time_from_first_x, gene_expr)) +
            geom_point(alpha = 0.7, size=0.7) +
            geom_line(aes(group = individual_id), alpha = 0.7, size=0.8)

    }
        
    estimates_only <- estimates_only +             
        xlab("Time from first symptoms (days)") +
        ylab(paste0(gene_name, " expression (TMM normalised logCPM)"))
        
    ggsave(paste0(output_dir, gene_name, "_effects.svg"), estimates_only, device="svg", width=78.123*1.8, height=63.760*1.5, units = "mm")
    ggsave(paste0(output_dir, gene_name, "_raw.svg"), raw_plot, device="svg", width=78.123*1.8, height=63.760*1.5, units = "mm")
    
    return(list(
        "estimates_only" = estimates_only,
        "raw_plot" = raw_plot
    ))
}
